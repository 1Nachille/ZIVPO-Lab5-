# ZIVPO-Lab5-
# Лабораторная работа 5


## DAST
Целевое приложение: `vulnerable_app.py` (Flask-приложение)

## Шаги развертывания:

**Создание виртуального окружения**

`python3 -m venv venv`

**Активация (Linux/Mac)**

`source venv/bin/activate`

<img src="https://github.com/1Nachille/ZIVPO-Lab5-/blob/main/images/Снимок_экрана_2025-12-14_200911.jpg" width="800" height="600">




**Установка зависимостей**

pip install Flask==2.3.3 requests==2.31.0

<img src="https://github.com/1Nachille/ZIVPO-Lab5-/blob/main/images/Снимок_экрана_2025-12-14_201118.jpg" width="800" height="600">

**Запуск приложения**

python vulnerable_app.py

Результат: Приложение успешно запущено и доступно по адресу http://localhost:5000.

<img src="https://github.com/1Nachille/ZIVPO-Lab5-/blob/main/images/Снимок_экрана_2025-12-14_201825.jpg" width="800" height="600">


## Сканирование с использованием OWASP ZAP

Сначала запустили ZAPROXY из меню Kali Linux и создали новый контекст с целевым URL: http://localhost:5000, затем запустили автоматическое сканирование (сначала Spider + Actie scan)

<img src="https://github.com/1Nachille/ZIVPO-Lab5-/blob/main/images/Снимок_экрана_2025-12-14_215329.jpg" width="800" height="600">

Затем выполнили фаззинг через интерфейс ZAP. Для этого выбрали запрос GET:search(q) в History. Выбрали параметр q и добавили payloads из файла

<img src="https://github.com/1Nachille/ZIVPO-Lab5-/blob/main/images/Снимок_экрана_2025-12-14_215805.jpg" width="800" height="600">
<img src="https://github.com/1Nachille/ZIVPO-Lab5-/blob/main/images/add_fuzz_file.jpg" width="800" height="600">

По итогу вот что получилось после полного сканирования инструментом Zaproxy

<img src="https://github.com/1Nachille/ZIVPO-Lab5-/blob/main/images/Снимок_экрана_2025-12-14_223950.jpg" width="800" height="600">

## Сканирование с использованием Nikto

Для дополнительного анализа используем Nikto. 
```bash

sudo apt update
sudo apt install nikto
nikto -h http://localhost:5000 -0 nikto_otchet.html -Format html
```
В итоге получем вот такой отчет
<img src="https://github.com/1Nachille/ZIVPO-Lab5-/blob/main/images/nitko_pro1.jpg" width="800" height="600">
<img src="https://github.com/1Nachille/ZIVPO-Lab5-/blob/main/images/nikto_pro2.jpg" width="800" height="600">

## ТРИАЖ УЯЗВИМОСТЕЙ

В рамках выполнения лабораторной работы был развернут уязвимый веб-приложение OWASP Juice Shop, доступное по адресу:

`http://localhost:3000`

Для динамического анализа и выявления уязвимостей использовался инструмент OWASP ZAP (Zed Attack Proxy)
Сканирование включало в себя:

* Spider-обход приложения;

* Активное сканирование выявленных точек входа;

* Фаззинг параметров HTTP-запросов.

<img src="https://github.com/1Nachille/ZIVPO-Lab5-/blob/main/images/OWASP_triage.jpg" width="800" height="600">

По результатам анализа был сформирован отчёт OWASP ZAP, содержащий 12 различных типов уязвимостей с уровнями риска от Informational до High.


**Выбор уязвимостей для триажа**

Для проведения триажа были отобраны следующие уязвимости из отчёта OWASP ZAP:

* SQL Injection (SQLite) — уровень риска High

* Content Security Policy (CSP) Header Not Set — уровень риска Medium

* Session ID in URL Rewrite — уровень риска Medium

* Cross-Domain Misconfiguration — уровень риска Medium

* Timestamp Disclosure (Unix) — уровень риска Low










| Критерий                        | **SAST (Bandit, Fortify)**                                                                                                                              | **DAST (ZAP, Nikto)**                                                                                                                                                |
| ------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Обнаруженные SQL-инъекции**   | **1 потенциальная** SQL-инъекция (Bandit B608 — строковая конкатенация SQL, confidence Low). Обнаружена на уровне кода, без подтверждения эксплуатации. | **2 подтверждённые** SQL Injection (ZAP: *SQL Injection – SQLite*, High risk). Эксплуатация подтверждена реальными HTTP-запросами.                                   |
| **Обнаруженные XSS-уязвимости** | **0**. SAST не выявил XSS, т.к. анализ без выполнения кода и контекста шаблонов.                                                                        | **2 XSS**: 1 DOM-based + 1 Reflected (ZAP, High risk). Уязвимости воспроизводимы через браузер.                                                                      |
| **Ложные срабатывания**         | **Выше среднего**: есть находки с Low confidence (SQLi, requests без timeout). Требуется ручная валидация.                                              | **Низкие**: большинство уязвимостей подтверждены ответами сервера (payload → эффект). Информационные находки (заголовки) не являются ложными, но низкого приоритета. |
| **Время анализа**               | **Очень быстро** (секунды): анализ ~195 строк кода. Не требует запущенного приложения.                                                                  | **Дольше**: Nikto ~14 сек, ZAP — несколько минут (краулинг + атаки). Требуется запущенное приложение.                                                                |
| **Полнота покрытия**            | **Высокая на уровне кода**: видит hardcoded secrets, debug=True, pickle, subprocess, архитектурные ошибки, даже если код не используется.               | **Ограничена доступными endpoint’ами**: видит только то, что доступно по HTTP и реально исполняется. Не видит хардкод ключей и внутреннюю логику.                    |
| **Простота использования**      | **Средняя**: нужно уметь интерпретировать отчёты и код (CWE, confidence, false positives).                                                              | **Высокая**: отчёты наглядные, payload → результат, легко демонстрировать уязвимость.                                                                                |


# Ответы на контрольные вопросы

**1. В чем принципиальное отличие SAST от DAST?**

**SAST (Static Application Security Testing)** анализирует исходный код или бинарные файлы приложения без его запуска.
**DAST (Dynamic Application Security Testing)** анализирует работающее приложение путём отправки запросов и анализа ответов.



**2. Какие типы уязвимостей лучше обнаруживает SAST?**

SAST наиболее эффективно обнаруживает:

* SQL-инъекции на уровне кода;
* XSS, связанные с ошибками экранирования;
* ошибки аутентификации и авторизации;
* использование небезопасных функций и API;
* утечки чувствительных данных в исходном коде.



**3. Какие типы уязвимостей лучше обнаруживает DAST?**

DAST лучше выявляет:

* SQL Injection и XSS при обработке HTTP-запросов;
* ошибки конфигурации (CORS, CSP, security headers);
* проблемы управления сессиями;
* уязвимости бизнес-логики;
* ошибки, зависящие от окружения и конфигурации сервера.


**4. Почему важно использовать оба метода в процессе разработки?**

SAST и DAST дополняют друг друга. SAST позволяет выявлять уязвимости на ранних этапах разработки, а DAST демонстрирует, как эти уязвимости проявляются в работающем приложении. Использование обоих методов обеспечивает более полное покрытие безопасности.


**5. Какие ограничения имеют каждый из методов?**

*Ограничения SAST:*

* не учитывает реальные настройки окружения;
* возможны ложные срабатывания;
* не выявляет ошибки логики выполнения.

*Ограничения DAST:*

* не имеет доступа к исходному коду;
* зависит от покрытия тестируемых сценариев;
* сложнее выявляет скрытые логические ошибки.



**6. Что такое AppSec?**

**AppSec (Application Security)** — это совокупность процессов, методов и инструментов, направленных на обеспечение безопасности приложений на всех этапах их жизненного цикла: от проектирования и разработки до эксплуатации.


**7. Что такое триаж уязвимостей и каковы его основные цели?**

Триаж уязвимостей — это процесс анализа результатов сканирования, направленный на подтверждение реальности уязвимостей, оценку их критичности, определение приоритетов устранения и отсеивание ложных срабатываний.

**8. Чем простое сканирование на уязвимости отличается от полноценного процесса триажа?**

Автоматическое сканирование лишь выявляет потенциальные уязвимости, тогда как триаж включает их проверку, оценку риска, анализ влияния на бизнес и принятие решений о дальнейших действиях.

**9. Почему автоматический сканер не может полностью заменить человека в процессе триажа?**

Автоматический сканер не учитывает бизнес-контекст, архитектуру приложения и реальные сценарии эксплуатации. Аналитик компенсирует эти ограничения за счёт опыта, понимания логики приложения и оценки реальных рисков.

**10. Почему важно документировать решение об отложении исправления уязвимости с низким приоритетом?**

Документирование позволяет зафиксировать осознанное управленческое решение, обеспечить прозрачность, упростить аудит и вернуться к оценке риска при изменении условий.

